# Python. Лабораторная работа 1   
### Калькулятор (E1 + M1)
- **Библиотеки:**
  - `dataclass` - _Хранение токенов_
  - `enum` - _Перечисление типов токенов_
  - `abc` - _Абстрактный класс Calculator_
  - `colorama` - _Цветной вывод (теги, вход)_
   
- **Интересные штучки:**
  - Ноль в дробных можно опускать: `.5 = 0.5`
  - Округление до двух символов после запятой, если выражение в конце целое - ответ в int
  - '//' и '%' разрешены только для целых чисел, **однако!**
    
    ```Python
    (4.5+0.5)//4 = 1  # Т.е. тип проверяется перед делением
    ```
  - Унарные знаки идут отдельным токеном
  - Правая ассоциативность в степени: `2**3**2 = 512`
  - Сначала степень, потом унарный минус: `-2**2 = -4`
  - Ноль в нулевой степени по-питоновски: `0**0 = 1`
  - Лимиты на степень и количество токенов можно изменить в [src/common/utils/vars.py](./src/common/utils/vars.py)
  - Есть преобразования: _(упрощение выражения, неявное умножение, "защита" от опечатки в конце и от пробелов между целыми числами)_
    
    ```Python
    │  ++2  ->  2   │  --2  -> 2     │  1 2 3 -> 123
    │  2++2 -> 2+2  │  4+5+ -> 4+5   │  5 5.0 -> error
    │  +-2  -> -2   │  2(2) -> 2*(2) │  1,5   -> 1.5
    ```
  - Реализован мини терминал: _выбор лабораторной работы, выход, настройки_
  - Сомнительная, но поддержка комплексных чисел: _предупреждение + type<complex>_
  - Все кастомные ошибки в коде наследуются от `CalcError`, которая в свою очередь наследуется от `Exception`, но с новым методом `print_error()` – именно через него выводятся все ошибки:
    > `InvalidTokenError` указывает курсором, в каком токене ошибка
  
### Что нового я познал?
- Впервые написал на Python программу, разбитую на несколько файлов.
- В новинку было написать кастомные ошибки и тесты
- Научился оформлять `README.md`

> [!NOTE]
> E1 делал, чтобы привыкнуть к Python. Далее весь отчёт будет относиться больше к M1

## Структура проекта

 <pre>
    │
    ├── lab_1                                  # Кодовая база лабораторной работы
    │   ├── src/                               # Исходный код
    │       ├── implementations/               # Реализации калькуляторов   
    │       ├── common/                        # Общий код для них: Токенизация, ABC Calculator, Utils (errors, operators, terminal)                   
    │       ├── main.py                        # Входная точка в программу
    │   ├── tests/                             # Unit тесты
    │   ├── uv.lock                            # Зависимости проекта
    │   ├── .gitignore                         # .gitignore файл
    │   ├──.pre-commit-config.yaml             # Средства автоматизации проверки кодстайла
    │   ├── README.md                          # Описание вашего проекта, с описанием файлов и с титульником о том,
    │                                          # что и какая задача
</pre>

> [!IMPORTANT]
>**ВАЖНОЕ УТОЧНЕНИЕ:** По ТЗ грамматика и приоритеты такие:
>  
>  ```
>    Приоритеты: 1) унарные; 2) ** (право-ассоц.); 3) * / // %; 4) + -
>    ГРАММАТИКА:
>    - expr → add
>    - add → mul ((+|-) mul)*
>    - mul → pow ((*|/|//|%) pow)*
>    - pow → unary (** pow)?
>    - unary → (+|-) unary | primary
>    - primary → NUM | ( expr )
>  ```
>  Но с ними невозможно _`ну, у меня не получилось =)`_ получить `-2**2 = -4` (как было оговорено в [чате](https://t.me/c/2907049440/5/2461)), т.к. unary выполняется перед возведением в степень, т.е. `(-2)**2 = 4`.
>  Поэтому я чуть изменил работу с унарными знаками:
>  
>  ```
>    Приоритеты: 1) унарные В СТЕПЕНИ (right); 2) ** (право-ассоц.); 3) унарные ДО СТЕПЕНИ (left); 4) * / // %; 5) + -
>    ГРАММАТИКА:
>    - expr → add
>    - add → mul ((+|-) mul)*
>    - mul → left_unary (((*|/|//|%) left_unary)*
>    - left_unary → (+|-)* pow
>    - pow → right_unary() (** pow)? 
>    - right_unary → (+|-)* primary
>    - primary → NUM | ( expr )
>  ```
>  Теперь приоритет степени > унарный знак до неё -> `-2**2 = -(2**2)=-4`

## Алгоритм:
1) Выбор варианта лабы + памятка о командах (help - вывести памятку, :q - выйти, :d - вкл/выкл debug, :w - вкл/выкл warnings)
2) После выбора M1, пользователь вводит выражение
3) Выражение разбирается токенизатором через регулярки на токены
   
   ```Python
   # Элемент → Токен
   if re.match(r'^[-+]?\d*\.?\d+$', element):  # Чекаем число ли 
     value = float(element) if '.' in element else int(element)
     num_token = Token(TOKEN_TYPES.NUM, abs(value))
  
     if (unary := element[0]) in (TOKEN_TYPES.MINUS.value, TOKEN_TYPES.PLUS.value):  # Проверяем на наличие знака
       self._tokens += [Token(TOKEN_TYPES(unary)), num_token]  # Если есть, добавляем его отдельным токеном
     else:
       self._tokens.append(num_token)
   else:
     self._tokens.append(Token(TOKEN_TYPES(element)))  # Добавляем остальные элементы
   ```
4) После чего токены отправляются в [`TokensValidator`](./src/common/tokenization/tokens_validator.py), где их проверяют на корректность и упрощают:
    - Проверяем валидность токенов: есть ли там числа и с какого токена начинается список
    - Циклом проходим по каждому токену, поддерживая стек скобок, смотря на токены впереди _(упрощение +-)_ и сзади _(неявное умножение)_, а также смотрим на последовательности NUM, чтобы объединять, если между целыми числами стоит пробел
    - Проверяем кол-во скобок и очищаем последние лишние операторы, если таковы есть
    - Добавляем EOF (он создаёт +1 элемент, чтобы калькулятор _(а именно его `pos`)_ не выходил за границы списка отфильтрованных токенов)
5) После этого, токены попадают в `Calculator` _(в `self._tokens`)_
    - Проверяем длину токенов на < `TOKENS_LIMIT`
    - Находим выражение через `self._expr()`:

      ```Python
      # Docstring из `CalculatorM1.solve()`
      # Работает в соответствии с обновлённой грамматикой и приоритетами
      expr() -> add() – сложение/вычитание:
        - Левый операнд (result) = mul()
        - Обработка в цикле +=mul() или -=mul() к result
      mul() - умножение/деление/остаток:
        - Левый операнд (result) = left_associated_unary()
        - Обработка в цикле (*|/|//|%)=left_associated_unary()
      left_associated_unary() - унарные знаки для ВСЕГО выражения:
        - Обрабатывает последовательности унарных +/-
        - Вызывает pow() для дальнейшего разбора
      pow() – степень (право-ассоц.):
        - Левый операнд (result) = right_associated_unary()
        - Обработка в цикле **pow() к result
      right_associated_unary() — унарные знаки только для ОСНОВАНИЯ степени:
        - Обрабатывает последовательности унарных +/-
        - Вызывает primary() для получения числа
      primary() — числа и скобки:
        - Обрабатывает числа или выражения в скобках
      ```
    - Проверяем тип полученного результата и выводим его пользователю _(функция `solve_and_print`)_
6) [Конечно же](./src/common/utils/errors.py), это всё обёрнуто в `try-catch: ZeroDivisionError, CalcError, ValueError`:
    - Важно отметить, что кастомные ошибки хэндлятся как-то так _(удобно, позже можно расширить как душе угодно)_
      
      ```python
      try:
        calculator.solve_and_print(expr)
      except CalcError as e:
        e.print_error()
      ```
      
## Примеры тестов _(281 шт...)_
#### Токенизация _(почти руками)_
> Использовал функцию, которая из токенов переводит в строку обратно:
> `tokens_to_expression(tokenize(expression)) == exception`
```python
  │  1 2 3   -> 123    │  5+  -> 5  │  -+-+-5     -> -5
  │  2 3+4 5 -> 23+45  │  3*/ -> 3  │  (1+1)(2+2) -> (1+1)*(2+2)
```
#### Fine expressions _(через `eval`)_
```python
  │  10 % (2.5 * 2)    │  (2**3)**2 │  -2**2  │ 2**(3+4*5)-17**3//29+45*(67-89//3)**2%77-1234//56+9876*543//210
  │  2.0 % 3           │  2**3**2   │  -2**-1 │ # dalshe скучные тесты
```
#### Calculator Errors _(`pytest.raises`)_
```python
                                    # на E1 InputError вызывается из-за '%' и скобок
 │  NoNumbersError │  FloatTogetherError  │  InvalidInputError  │  NotIntegerDivisionError │  InvalidExprStartError   │
 │   (+) │ + │ *   │  1.5 2.5 │ 2.3.4 + 5 │ 2 @ 3 │ hello world │ 5.5 // 2 │ 10 // 2.5     │   * 5 + 2 │ )5 + 3(      │
 │   (-) │  *-*/   │  0.1 0.2 + 3.14 2.71 │ a + b │ 2 & 3 | 4   │ 5.5 % 2" │ (5.5 + 2) % 3 │    / 10   │ // 10        │
 ├────────────────────────────────────────────────────────────────────────────────────────────────────────────────────│  
 │    InvalidTokenError   │ InvalidParenthesisError(0) │ InvalidParenthesisError(1) │  ZeroDivisionError │ ValueError │  
 │   2 + * 3   │ (5 + ) 3 │    (32131))( │ (2 + 3))    │   ((1+2)*(3+4) │ (2 + 3    │ 5 / 0  │  5 % 0    │ "9" * 5000 │
 │ 10 * (2 + ) │ 5 // / 2 │    2+(3* 4)) │ ((2+3)))    │ ((2 + 3) *(4-1 │ (((5+2)*3 │ 5 // 0 │  0**-1    │ "123"*2000 │
 # Ещё есть EmptyExpressionError и вот тесты на неё: 
```

## Quick start
 1) Клонировать этот репозиторий через git и активировать uv или **просто** установить через pip:
   `pip install -e git+https://github.com/nevrozza/mai-lab-calculator#egg=calculator`
 2) Перейти к корневой папке:
    `cd src/calculator`
 4) Запустить программу через `uv`:
    `uv run -m src.main`
>_У вас же он скачан, не так ли? 0_о_


