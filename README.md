# Python. Лабораторная работа 1   
### Калькулятор (E1 + M1)
- **Библиотеки:**
  - `dataclass` - _Хранение токенов_
  - `enum` - _Перечисление типов токенов_
  - `abc` - _Абстрактный класс Calculator_
  - `colorama` - _Цветной вывод (теги, вход)_
   
- **Интересные штучки:**
  - Округление до двух символов после запятой, если выражение в конце целое - ответ в int
  - '//' и '%' разрешены только для целых чисел, **однако!**
    
    ```Python
    (4.5+0.5)//4 = 1  # Т.е. тип проверяется перед делением
    ```
  - Унарные знаки идут отдельным токеном
  - Правая ассоциативность в степени: `2**3**2 = 512`
  - Сначала степень, потом унарный минус: `-2**2 = -4`
  - Ноль в нулевой степени по-питоновски: `0**0 = 1`
  - Лимиты на степень и количество токенов можно изменить в [src/common/utils/vars.py](https://github.com/nevrozza/mai-lab-calculator/blob/main/src/common/utils/vars.py)
  - Есть преобразования: _(упрощение выражения, неявное умножение, "защита" от опечатки в конце и от пробелов между целыми числами)_
    
    ```Python
    |  ++2  ->  2   |  --2  -> 2     |  1 2 3 -> 123
    |  2++2 -> 2+2  |  4+5+ -> 4+5   |  5 5.0 -> error
    |  +-2  -> -2   |  2(2) -> 2*(2) |  1,5   -> 1.5
    ```
  - Реализован мини терминал: _выбор лабораторной работы, выход, настройки_
  - Сомнительная, но поддержка комплексных чисел: _предупреждение + type<complex>_
  
### Что нового я познал?
- Впервые написал на питоне программу, разбитую на несколько файлов.
- В новинку было написать кастомные ошибки и тесты


## Структура проекта

 <pre>
    │
    ├── lab_1                                  # Кодовая база лабораторной работы
    │   ├── src/                               # Исходный код
    │       ├── implementations/               # Реализации калькуляторов   
    │       ├── common/                        # Общий код для них: Токенизация, ABC Calculator, Utils (errors, operators, terminal)                   
    │       ├── main.py                        # Входная точка в программу
    │   ├── tests/                             # Unit тесты
    │   ├── uv.lock                            # Зависимости проекта
    │   ├── .gitignore                         # .gitignore файл
    │   ├──.pre-commit-config.yaml             # Средства автоматизации проверки кодстайла
    │   ├── README.md                          # Описание вашего проекта, с описанием файлов и с титульником о том,
    │                                          # что и какая задача
</pre>

### Алгоритм (M1)
- ВАЖНОЕ УТОЧНЕНИЕ: 
  По ТЗ грамматика и приоритеты такие:
  
  ```
    Приоритеты: 1) унарные; 2) ** (право-ассоц.); 3) * / // %; 4) + -
    ГРАММАТИКА:
    - expr → add
    - add → mul ((+|-) mul)*
    - mul → pow ((*|/|//|%) pow)*
    - pow → unary (** pow)?
    - unary → (+|-) unary | primary
    - primary → NUM | ( expr )
  ```
  Но с ними невозможно _`ну, у меня не получилось)))`_ получить `-2**2 = -4` (как было оговорено в [чате](https://t.me/c/2907049440/5/2461)), т.к. unary выполняется перед возведением в степень, т.е. `(-2)**2 = 4`.
  Поэтому я чуть изменил работу с унарными знаками:
  
  ```
    Приоритеты: 1) унарные В СТЕПЕНИ (right); 2) ** (право-ассоц.); 3) унарные ДО СТЕПЕНИ (left); 4) * / // %; 5) + -
    ГРАММАТИКА:
    - expr → add
    - add → mul ((+|-) mul)*
    - mul → left_unary (((*|/|//|%) left_unary)*
    - left_unary → (+|-)* pow
    - pow → right_unary() (** pow)? 
    - right_unary → (+|-)* primary
    - primary → NUM | ( expr )
  ```
  Теперь приоритет степени > унарный знак до неё -> `-2**2 = -(2**2)=-4`
  




